<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Joez Better Trademark Styling for the Registered and Trademark Symbols</title>
    <style>
        /* CSS to style registered and trademark symbols */
        .symbol-sup {
            font-size: 0.6em; /* Smaller size to mimic superscript */
            vertical-align: super; /* Positions text higher like <sup> */
            line-height: normal; /* Prevents line spacing issues */
        }
    </style>
</head>
<body>
    <h1>Joez Better Trademark Styling for the Registered and Trademark Symbols</h1>
    <h2>CSS:</h2>
    <p>The `.reg-trademark` and `.trademark` classes use `font-size: 0.6em` and `vertical-align: super` to mimic the superscript appearance of <pre><sup>&reg;</sup></pre> and <pre><sup>&trade;</sup></pre>. </p>
      
    <h2>JavaScript:</h2>
    <p>Uses a `TreeWalker` to select text nodes, explicitly excluding those within <pre><sup></pre> or <pre><script></pre> tags via the `acceptNode` filter. </p>
    <p>Applies a regular expression <pre>(®|&reg;|™|&trade;)</pre> to match standalone symbols. </p>
    <p>Wraps matched symbols in <pre><span class="symbol-sup"></pre> tags. </p>

    <h2>Behavior:</h2>
    <p>Standalone ®, &reg;, ™, and &trade; are styled to appear superscripted. </p>
    <p>This solution ensures that only standalone ®, &reg;, ™, and &trade; symbols are styled, leaving <pre><sup>&reg;</sup></pre> and <pre><sup>&trade;</sup></pre> untouched. </p>

    <h2>Example:</h2>
    <ul>
      <li>This is a test of symbols: ®, &reg;, ™, and &trade; in text</li>
      <li>BrandName® and BrandName&reg; should appear superscripted</li>
      <li>ProductName™ and ProductName&trade; should also appear superscripted</li>
      <li>Ignored cases: BrandName<sup>&reg;</sup> and ProductName<sup>&trade;</sup> remain unchanged</li>
    </ul>
  
    <script>
        // JavaScript to wrap standalone ®, &reg;, ™, and &trade; in spans with symbol-sup class
        document.addEventListener('DOMContentLoaded', () => {
            let totalReg = 0;
            let totalTm = 0;
        
            function wrapSymbols() {
                let regCount = 0;
                let tmCount = 0;
        
                const walker = document.createTreeWalker(
                    document.body,
                    NodeFilter.SHOW_TEXT,
                    {
                        acceptNode: (node) => {
                            // 1. Skip if already inside .symbol-sup
                            if (node.parentNode?.closest('.symbol-sup')) {
                                return NodeFilter.FILTER_REJECT;
                            }
                            // 2. Skip excluded areas
                            if (node.parentElement?.closest('sup, script, style, .card-footer')) {
                                return NodeFilter.FILTER_REJECT;
                            }
                            return NodeFilter.FILTER_ACCEPT;
                        }
                    }
                );
        
                const nodes = [];
                let node;
                while (node = walker.nextNode()) nodes.push(node);
        
                const regExp = /(®|™|&reg;|&trade;)/g;
        
                nodes.forEach(textNode => {
                    if (!regExp.test(textNode.textContent)) return;
        
                    const replaced = textNode.textContent.replace(regExp, (match) => {
                        if (match === '®' || match === '&reg;') regCount++;
                        if (match === '™' || match === '&trade;') tmCount++;
                        return `<span class="symbol-sup">${match}</span>`;
                    });
        
                    if (replaced !== textNode.textContent) {
                        const temp = document.createElement('div');
                        temp.innerHTML = replaced;
                        const fragment = document.createDocumentFragment();
                        while (temp.firstChild) fragment.appendChild(temp.firstChild);
                        textNode.replaceWith(fragment);
                    }
                });
        
                totalReg += regCount;
                totalTm += tmCount;
        
                // Optional: show final counts once
                if (regCount || tmCount) {
                    console.log(`Wrapped: ${regCount} ®/&reg;, ${tmCount} ™/&trade; (total so far: ${totalReg}/${totalTm})`);
                }
            }
        
            // Run once immediately
            wrapSymbols();
        
            // Then watch for any future text injections (ConveyThis, etc.)
            const observer = new MutationObserver((mutations) => {
                let needsProcessing = false;
        
                for (const m of mutations) {
                    if (m.type === 'childList') {
                        for (const node of m.addedNodes) {
                            if (node.nodeType === Node.TEXT_NODE && /(®|™|&reg;|&trade;)/.test(node.textContent)) {
                                needsProcessing = true;
                            }
                            if (node.nodeType === Node.ELEMENT_NODE && node.textContent && /(®|™|&reg;|&trade;)/.test(node.textContent)) {
                                needsProcessing = true;
                            }
                        }
                    }
                    // characterData catches direct text edits
                    if (m.type === 'characterData' && /(®|™|&reg;|&trade;)/.test(m.target.textContent)) {
                        needsProcessing = true;
                    }
                }
        
                if (needsProcessing) {
                    // Tiny debounce so multiple rapid mutations don't trigger 20 runs
                    clearTimeout(window._symbolWrapTimer);
                    window._symbolWrapTimer = setTimeout(wrapSymbols, 150);
                }
            });
        
            observer.observe(document.body, {
                childList: true,
                subtree: true,
                characterData: true
            });
        
            // Final stats (optional)
            setTimeout(() => {
                console.table([
                    { Symbol: '® / &reg;', Count: totalReg },
                    { Symbol: '™ / &trade;', Count: totalTm }
                ]);
            }, 5000);
        });
    </script>
</body>
</html>
